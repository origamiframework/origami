# Environment
env.missing.property=Missing property: %s
env.missing.stand.value=Missing required property: %s
env.empty.config.file=Config "{}" is empty
env.not.found.config.file=Config "{}" not found
env.fail.not.found.config.file=Config "/resources/config/%s" not found
env.fail.load.config.file=Failed load properties by path: "%s"
env.fail.load.trust.store=Error occurred while adding "javax.net.ssl.trustStore"
env.empty.trust.store.password=No password set [{}] for [{}]
env.not.exists.trust.store.file=File does not exist at path "%s". Property [%s]
env.custom.properties.loaded=Custom configuration file "{}" loaded

# Common
xml.string.not.parsed=String not parsed. Format does not match XML.\n%s
common.string.not.parsed=String not parsed. %s\n\n%s
xml.annotation.not.found=XML annotation "jakarta.xml.bind.annotation.XmlRootElement" not found in the passed class
xml.object.not.parsed=Object not parsed to XML string. %s
json.object.not.parsed=Object not parsed to JSON string. %s
file.copy.error=Failed to copy from file [%s] to another file [%s]. %s
file.clear.error=Failed to clean file [%s]. %s
file.not.found.error=Failed to get information from file [%s]. File not found. %s
file.write.error=Failed to write to file [%s]. %s
reflection.change.field.error=Failed to change field [%s]. %s
xsd.validation.error=Error validating XML against XSD schema. %s
method.name.empty.error=Method name must be filled in
no.such.method.error=Method %s%s not found. Possible cause: The sequence of parameters passed to the constructor does not match the sequence in the called method
method.called.error=Error occurred while executing "%s": %s
could.not.find.parameter=Could not find parameter "%s"
could.not.find.parameter.template=Could not find parameter "%s" for "%s"
unable.to.extract.value=Unable to extract "%s" value from %s. No field "%s"
unable.to.extract.value.template=Unable to extract "%s" value for "%s" from %s. No field "%s"
ssl.verification.error=An error occurred while disabling SSL verification
allure.excel.json.error=No JSON files found at path [%s]
allure.excel.error=An error occurred while generating the Excel report
allure.excel.field.name=Name
allure.excel.field.result=Result
allure.excel.field.duration=Duration (ms)
origami.helper.step.wait=Waiting {millis} ms

# Kafka
kafka.props.null=Kafka properties is null
kafka.cannot.connect=Cannot connect to Kafka\n%s\n
kafka.message.not.posted=Message has not posted to topic: %s
kafka.fail.sent=Fail while sent message to topic: %s\n%s\n
kafka.fail.subscribe=Fail subscribe for topic: %s\n%s\n
kafka.success.subscribe=Success subscribe for topic: {}\n
kafka.success.subscribe.with.partition=Successful subscription to partition [{}] of topic: {}\n
kafka.success.subscribe.with.partitions=Successful subscription to partitions [{}] of topic: {}\n
kafka.no.records=No records find by keys: %s
kafka.not.parsed.records=Records are not parsed: {}
kafka.attempt=Attempt: {}
kafka.no.records.while.subscribe=No records were received in topic "%s" during subscription period containing: %s
kafka.fail.unsubscribe.no.subscribe=Fail unsubscribe from topic "%s". Subscribe on topic not found.
kafka.many.subscribes=Find {} subscribes on topic "{}"
kafka.test.data.read.error=Error while reading file.\n%s
kafka.success.sent=Message successfully sent to topic: {}\nPartition: {}\nKey: {}\nValue: {}
kafka.success.read=Message successfully read from topic: {}\n{}\n
kafka.success.read.many=Messages successfully read from topic: {}\n{}\n
kafka.end.read=End read from topic: {}\n{}\n
kafka.no.existing.partition=A non-existent partition [%s] was specified. Possible partitions: [%s]
kafka.no.existing.partitions=A non-existent partitions [%s] was specified. Possible partitions: [%s]
kafka.no.partitions=Missing partitions for topic [%s]. Check that topic name is correct.
kafka.formatted.record=Key: %s\nTimestamp: %s\nValue: %s\n
kafka.incorrect.security.protocol.mapping=Missing configuration for SecurityProtocol: %s, SaslMechanism: %s
kafka.empty.security.protocol=securityProtocol not set
kafka.empty.ssl.truststore.location=sslTruststoreLocation not set
kafka.empty.ssl.truststore.password=sslTruststorePassword not set
kafka.empty.ssl.keystore.password=sslKeystorePassword not set
kafka.empty.ssl.key.password=sslKeyPassword not set
kafka.empty.sasl.kerberos.service.name=saslKerberosServiceName not set
kafka.empty.sasl.oauth.bearer.token.endpoint=saslOauthBearerTokenEndpoint not set
kafka.empty.sasl.oauth.bearer.jwks.endpoint=saslOauthBearerJwksEndpoint not set
kafka.empty.client.id=clientId not set
kafka.empty.client.secret=clientSecret not set
kafka.empty.username=username not set
kafka.empty.password=password not set
kafka.step.consumer.read.first=Read message from the topic: "{topic}" by search words: {logValue}
kafka.step.consumer.read.all=Read messages from the topic: "{topic}" by search words: {logValue}
kafka.step.consumer.subscribe=Subscribe to the topic: "{topic.topic}"
kafka.step.consumer.unsubscribe.after.key=Unsubscribe from the topic: "{topic}" after receiving message containing: {logValue}
kafka.step.producer.send=Send message to the topic: {topic}

# Hibernate
hibernate.null.attachment=Allure attachment is null
hibernate.empty.result=Result of query is empty
hibernate.query.word=SQL query
hibernate.result.word=Result
hibernate.updated.words=Updated
hibernate.updated.word=Updated
hibernate.deleted.words=Deleted
hibernate.deleted.word=Deleted
hibernate.inserted.words=Inserted
hibernate.inserted.word=Inserted
hibernate.one.row=row
hibernate.two.rows=rows
hibernate.many.rows=rows
hibernate.excel.result.value.error=Error while write value to Excel. %s
hibernate.excel.big.value=See data in DB. Length exceeds 32767 characters(32 KB)
hibernate.change.param.not.found=Parameter to change not found: %s
hibernate.max.result.zero.value.error=Value of [maxResult] must be greater than 0
hibernate.empty.result.query=No entity found for query
hibernate.not.valid.param.set.error=Not valid param set to query\n%s
hibernate.execute.query.error=Execute query failed\n
hibernate.set.param.error=Set parameter [%s] to query failed\n
hibernate.max.result.value.error=Fail while set [maxResult] value\n
hibernate.first.result.value.error=Fail while set [firstResult] value\n
hibernate.change.param.error=Change parameter [%s] to query failed\n
hibernate.query.error=Query was written with an error\n
hibernate.attempt=Attempt: {}
hibernate.props.null=Session Properties is null
hibernate.connect.to.db.error=Cannot connect to DataBase\n%s

# IBM MQ
ibm.mq.success.sent=Message successfully sent to queue: {}\n{}\n
ibm.mq.success.read=Message successfully read from queue: {}\n{}\n
ibm.mq.success.read.many=Messages successfully read from queue: {}\n{}\n
ibm.mq.end.read=End read from queue: {}. No messages found.\n
ibm.mq.convert.bytes.error=Cannot convert bytes message to string
ibm.mq.props.null=IBM MQ Properties is null
ibm.mq.connect.error=Cannot connect to IBM MQ\n
ibm.mq.close.conn.error=Cannot close connection with IBM MQ.\n%s\n
ibm.mq.attempt=Attempt: {}
ibm.mq.create.browser.error=Cannot create IBM MQ Browser
ibm.mq.create.consumer.error=Cannot create IBM MQ Consumer
ibm.mq.create.producer.error=Cannot create IBM MQ Producer
ibm.mq.browser.start.read=IBM MQ Browser. Start read messages from queue [{}]
ibm.mq.no.messages=No messages find
ibm.mq.read.fail=Fail while read messages
ibm.mq.consumer.start.read=IBM MQ Consumer. Start read messages from queue [{}]
ibm.mq.producer.start.sending=IBM MQ Producer. Start sending message to queue [{}]
ibm.mq.producer.error.sending=Message has not posted to queue
ibm.mq.step.consumer.read=Reading message from the queue: {queue.queue}
ibm.mq.step.browser.read=Reading message from the queue: {queue.queue}
ibm.mq.step.producer.send=Sending message to the queue: {queue.queue}

# Rest
rest.name.null.error=Name must not be null value
rest.url.null.error=Url must not be null value
rest.header.name.null.error=Header name must not be null value
rest.header.value.null.error=Header value must not be null value
rest.headers.null.error=Headers must not be null value
rest.cookie.name.null.error=Cookie name must not be null value
rest.cookie.value.null.error=Cookie value must not be null value
rest.cookies.null.error=Cookies must not be null value
rest.body.null.error=Body should not be null value
rest.method.null.error=Method must not be null value
rest.response.created.error=Response should be created
rest.step.response.body.should.be.empty=Response body should be empty
rest.step.response.contain.empty.list=Response should contain an empty list
rest.step.response.by.path.contain.empty.list=Response at path {0} should contain an empty list
rest.step.response.body.with.no.content=Response body should contain empty content
rest.step.response.body.by.path.should.be.empty=Response body at path {0} should be empty
rest.step.response.body.by.path.should.be.not.empty=Response body at path {0} should not be empty
rest.step.response.time.seconds.should.be.greater.than=Response time should be greater than {0} seconds
rest.step.response.time.seconds.should.be.less.than=Response time should be less than {0} seconds
rest.step.response.time.ms.should.be.greater.than=Response time should be greater than {0} ms
rest.step.response.time.ms.should.be.less.than=Response time should be less than {0} ms
rest.step.response.status.code=Response status code should be

#Selenide
selenide.web.site.url.is.empty=The "web.site.url" parameter is not set for use in Web UI tests
selenide.cookie.not.found.error=Cookie [%s] not found
selenide.step.open.url=Go to URL "{url}"
selenide.step.current.url=Get current URL
selenide.step.refresh.page=Refresh page
selenide.step.close.driver=Close browser
selenide.step.close.window=Close current browser tab
selenide.step.browser.size=Set browser window size to "{width} x {height}"
selenide.step.back=Back to page back
selenide.step.forward=Back to page forward
selenide.step.switch.to.window=Go to browser tab numbered {windowNumber}
selenide.step.get.local.storage=Get browser localStorage by key "{key}"
selenide.step.set.item.in.local.storage=Add localStorage with key "{key}"
selenide.step.get.cookies=Get browser cookies
selenide.step.get.cookie.by.name=Get browser cookie: {cookieName}
selenide.step.set.cookie=Set browser cookie: {cookieName}
selenide.step.clear.browser.local.storage=Clear browser cache
selenide.step.clear.browser.cookies=Clear browser cookies
selenide.step.clear.browser.cookies.and.local.storage=Clear browser cache and cookies
selenide.step.execute.java.script=Execute synchronous JavaScript in the browser
selenide.step.execute.async.java.script=Execute asynchronous JavaScript in the browser

# WebSocket
websocket.props.null=WebSocket Properties is null
websocket.connect.error=Cannot connect to WebSocket.\n%s
websocket.unsubscribe.no.topic.error=Topic [%s] has not been subscribed to
websocket.read.error=Fail while read from topic [%s]\n%s
websocket.subscribe.already.exist=Topic [%s] is already subscribed to
websocket.new.connect=New WebSocket established: {}
websocket.exception=WebSocket exception. {}
websocket.received=Received WebSocket messages:\n{}
websocket.disconnect=End WebSocket subscribe for topic: {}
websocket.connect.to.topic=Start WebSocket subscribe for topic: {}
websocket.no.records.while.subscribe=No messages received while subscribing to WebSocket topic: "%s"
websocket.step.subscribe=Subscribe to WebSocket topic: "{wsTopic.topic}"
websocket.step.unsubscribe.and.get.results=Unsubscribe from WebSocket topic: "{wsTopic.topic}" and get result

# Asserts
asserts.step.assert.true=Check "{field}": true
asserts.step.assert.false=Check "{field}": false
asserts.step.assert.null=Check "{field}": null
asserts.step.assert.not.null=Check "{field}": not null
asserts.step.assert.equals=Check "{field}": "{expected}"
asserts.step.assert.equals.with.delta=Check "{field}": "{expected}", delta: {delta}
asserts.step.assert.equals.with.ignoring.case=Check "{field}": "{expected}" with ignoring case
asserts.step.assert.lines.match=Check "{field}": "{expectedLines}"
asserts.step.assert.not.equals=Checking that "{field}" does not match "{unexpected}"
asserts.step.assert.not.equals.with.delta=Checking that "{field}" does not match "{unexpected}", delta: {delta}
asserts.step.assert.throws.exactly=Checking that "{executable}" does not contain exceptions
asserts.step.assert.does.not.throw=Checking that "{supplier}" does not contain exceptions
asserts.step.assert.timeout=Checking that "{executable}" runs for no more than {timeout}
asserts.step.assert.timeout.supplier=Checking that "{supplier}" runs for no more than {timeout}
asserts.step.assert.instance.of=Checking that "{actualValue}" is instance of {expectedType}
asserts.step.assert.list.equals=Check "{field}": "{expectedList}"
asserts.step.assert.list.contains=Checking that "{field}" contains "{expectedValue}"
asserts.step.assert.list.size=Checking size of the list "{field}": {size}
asserts.step.assert.time.is.after=Checking that "{field}" is after "{expected}"
asserts.step.assert.time.is.after.or.equal.to=Checking that "{field}" is after or equal to "{expected}"
asserts.step.assert.time.is.before=Checking that "{field}" is before "{expected}"
asserts.step.assert.time.is.before.or.equal.to=Checking that "{field}" is before or equal to "{expected}"
asserts.step.assert.time.is.between=Checking that "{field}" is between "{expectedStartTime}" and "{expectedEndTime}"
asserts.step.assert.date.is.between=Checking that "{field}" is between "{expectedStartDate}" and "{expectedEndDate}"
asserts.step.assert.time.is.between.or.equal.to=Checking that "{field}" is between or equal to "{expectedStartTime}" and "{expectedEndTime}"
asserts.step.assert.date.is.between.or.equal.to=Checking that "{field}" is between or equal to "{expectedStartDate}" and "{expectedEndDate}"
asserts.step.assert.start.with=Checking that "{field}" starts with "{expectedPrefix}"
asserts.step.assert.start.with.ignoring.case=Checking that "{field}" starts with "{expectedPrefix}" with ignoring case
asserts.step.assert.not.start.with=Checking that "{field}" does not start with "{expectedNotPrefix}"
asserts.step.assert.not.start.with.ignoring.case=Checking that "{field}" does not start with "{expectedNotPrefix}" with ignoring case
asserts.step.assert.end.with=Checking that "{field}" ends with "{expectedSuffix}"
asserts.step.assert.end.with.ignoring.case=Checking that "{field}" ends with "{expectedSuffix}" with ignoring case
asserts.step.assert.not.end.with=Checking that "{field}" does not end with "{expectedNotSuffix}"
asserts.step.assert.not.end.with.ignoring.case=Checking that "{field}" does not end with "{expectedNotSuffix}" with ignoring case
asserts.step.assert.not.equals.with.ignoring.case=Checking that "{field}" does not match "{notExpected}" with ignoring case
asserts.step.assert.equals.with.ignoring.whitespace=Checking "{field}": "{expected}" with ignoring whitespaces
asserts.step.assert.not.equals.with.ignoring.whitespace=Checking that "{field}" does not match "{notExpected}" with ignoring whitespaces
asserts.step.assert.contains.only.whitespaces=Checking that "{field}" contains only whitespaces
asserts.step.assert.contains.whitespaces=Checking that "{field}" contains whitespaces
asserts.step.assert.not.contains.whitespaces=Checking that "{field}" does not contain whitespaces
asserts.step.validate.xml.against.xsd.schema=Validating XML message against XSD schema

# Cartesian Source
cartesian.axis.no.value=Axis '%s' produced no values
cartesian.value.no.value=CartesianValue '%s' produced no values: at least one source must be defined
cartesian.bad.exclude.value=Bad exclude value: '%s'. Expected 'key=value'
cartesian.unknown.exclude.cartesian.value=Exclude refers to unknown CartesianValue: %s
cartesian.not.static.field=Field '%s' must be static
cartesian.cannot.read.field=Cannot read field '%s' in '%s'
cartesian.cannot.invoke.method=Cannot invoke method '%s' in '%s'
cartesian.found.unsuitable.methods=Found method(s) named '%s', but none is static and without parameters in '%s'
cartesian.no.found.methods=No method named '%s' found in '%s'
cartesian.unsupported.array=Unsupported provider return type: '%s'. Use Stream/Iterable/Array
cartesian.type.must.have.no.args.ctor=Cannot instantiate %s (must have no-arg constructor)
cartesian.axis.diff.sizes=Axis '%s' produced tuples with different sizes: %d vs %d. Make them consistent
cartesian.axis.column.length=Axis '%s': columns() length (%d) must match tuple arity (%d)

# Test Containers
test.containers.cmd.command.failed=Command failed (%s): %s
test.containers.cmd.failed.to.run=Failed to run in %s: %s
test.containers.cmd.service.sources.not.found=Service sources not found: %s. Clone service into this path or set SERVICE_SRC_DIR.
test.containers.cmd.service.jar.not.found=Service JAR not found in %s
test.containers.cmd.failed.to.rename=Failed to rename %s to %s.jar
test.containers.original.port.null=Parameter originalPort is null. You need to set a value. By default, for:\n- kafka: 9092\n- postgre: 5432\n- services: 8080
test.containers.database.started={} container started: image={}, jdbcUrl={}
test.containers.database.started.error=Error while starting %s container.\n%s
test.containers.kafka.started=Kafka container started: image={}, bootstrapServers={}
test.containers.kafka.started.error=Error while starting Kafka container.\n%s
test.containers.container.started=Container started: name={}, image={}, running={}, networkAliases={}, host={}, port={}
test.containers.non.standard.container.started=Startable started: {}
test.containers.container.started.error=The container "{}" with image {} failed to start.\n{}
test.containers.started.error=Error while starting the containers.\n%s
test.containers.kafka.topics.created=Kafka topics created: {}
test.containers.kafka.topics.created.error=Failed to create Kafka topics. bootstrapServers: %s
test.containers.no.implementation.error=No TestContainers-derived class found on classpath%s. Create at least one class extends TestContainers in the test project.
test.containers.no.implementation.filter= (filter by package: %s)
test.containers.multiple.found.error=Found multiple TestContainers descendants. Specify -Dtest.containers.name=<simpleName|FQN|@TestContainerName> %sto select one.
test.containers.multiple.found.error.pkg=or set -Dtest.containers.pkg.prefix=<prefix> 
test.containers.no.implementation.by.name.error=No TestContainers were found with the name "%s". The check is based on FQN, simpleName, and the value of @TestContainerName. The available candidates are:\n%s
test.containers.multiple.found.by.name.error=The name "%s" matched multiple classes. Specify the FQN (full package name) %s
test.containers.multiple.found.by.name.error.prefix=or set -Dtest.containers.pkg.prefix=<prefix>.
test.containers.looking.name=The name you are looking for: %s\n
test.containers.looking.candidates=%sCandidates:\n%s\n%s
test.containers.new.instance.error=Failed to create an instance of %s: %s