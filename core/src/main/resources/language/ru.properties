# Environment
env.missing.property=Не задан параметр: %s
env.missing.stand.value=Отсутствует обязательный параметр: %s
env.empty.config.file=Пустой файл конфигурации "{}"
env.not.found.config.file=Не найден файл конфигурации "{}"
env.fail.not.found.config.file=Не найден файл конфигурации "/resources/config/%s"
env.fail.load.config.file=Ошибка при загрузке файла конфигурации: "%s"
env.fail.load.trust.store=Произошла ошибка во время добавления "javax.net.ssl.trustStore"
env.empty.trust.store.password=Не задан пароль [{}] для [{}]
env.not.exists.trust.store.file=Не существует файл по пути "%s". Параметр [%s]
env.custom.properties.loaded=Загружен пользовательский файл конфигурации "{}"

# Common
xml.string.not.parsed=Строка не обработана. Формат не соответствует XML.\n%s
common.string.not.parsed=Строка не обработана. %s\n\n%s
xml.annotation.not.found=Не найдена аннотация "jakarta.xml.bind.annotation.XmlRootElement" у переданного класса
xml.object.not.parsed=Ошибка при преобразовании XML в строку. %s
json.object.not.parsed=Ошибка при преобразовании JSON в строку. %s
file.copy.error=Не удалось выполнить копирование из файла [%s] в другой файл [%s]. %s
file.clear.error=Не удалось выполнить очистку файла [%s]. %s
file.not.found.error=Не удалось получить информацию из файла [%s]. Файл не найден. %s
file.write.error=Не удалось выполнить запись в файл [%s]. %s
reflection.change.field.error=Не удалось изменить поле [%s]. %s
xsd.validation.error=Ошибка при валидации XML относительно XSD-схемы. %s
method.name.empty.error=Название метода должно быть заполнено
no.such.method.error=Не найден метод %s%s. Возможная причина: последовательность параметров, переданная в конструктор, не совпадает с последовательностью в вызываемом методе
method.called.error=Произошла ошибка во время выполнения "%s": %s
could.not.find.parameter=Не удалось найти параметр "%s"
could.not.find.parameter.template=Не удалось найти параметр "%s" для "%s"
unable.to.extract.value=Невозможно извлечь значение "%s" из %s. Отсутствует поле "%s"
unable.to.extract.value.template=Невозможно извлечь значение "%s" для "%s" из %s. Отсутствует поле "%s"
ssl.verification.error=Возникла ошибка при отключении проверки SSL
allure.excel.json.error=Не найдено JSON файлов по пути [%s]
allure.excel.error=Возникла ошибка при формировании Excel отчета
allure.excel.field.name=Название
allure.excel.field.result=Результат
allure.excel.field.duration=Продолжительность (мс)
origami.helper.step.wait=Ожидаем {millis} мс

# Kafka
kafka.props.null=Kafka параметры для подключения отсутствуют
kafka.cannot.connect=Ошибка при подключении к Kafka\n%s\n
kafka.message.not.posted=Сообщение не было отправлено в топик: %s
kafka.fail.sent=Ошибка при отправке сообщения в топик: %s\n%s\n
kafka.fail.subscribe=Произошла ошибка при подписке на топик: "%s"\n%s\n
kafka.success.subscribe=Успешная подписка на топик: {}\n
kafka.success.subscribe.with.partition=Успешная подписка на партицию [{}] топика: {}\n
kafka.success.subscribe.with.partitions=Успешная подписка на партиции [{}] топика: {}\n
kafka.no.records=Не найдено сообщений по ключам: %s
kafka.not.parsed.records=Сообщения не обработаны: {}
kafka.attempt=Попытка: {}
kafka.no.records.while.subscribe=За время подписки на топик "%s" не получено сообщений содержащих: %s
kafka.fail.unsubscribe.no.subscribe=Не удалось отписаться от топика "%s". Подписка на топик не найдена.
kafka.many.subscribes=Найдено {} подписок на топик "{}"
kafka.test.data.read.error=Ошибка при попытке чтения файла.\n%s
kafka.success.sent=Сообщение успешно отправлено в топик: {}\nПартиция: {}\nКлюч: {}\nЗначение: {}
kafka.success.read=Сообщение успешно вычитано из топика: {}\n{}\n
kafka.success.read.many=Сообщения успешно вычитаны из топика: {}\n{}\n
kafka.end.read=Окончена вычитка из топика: {}\n{}\n
kafka.no.existing.partition=Задана несуществующая партиция [%s]. Возможные партиции: [%s]
kafka.no.existing.partitions=Заданы несуществующие партиции [%s]. Возможные партиции: [%s]
kafka.no.partitions=Отсутствуют партиции для топика [%s]. Проверьте корректность названия топика
kafka.formatted.record=Ключ: %s\nВремя: %s\nЗначение: %s\n
kafka.incorrect.security.protocol.mapping=Отсутствует конфигурация для SecurityProtocol: %s, SaslMechanism: %s
kafka.empty.security.protocol=Не задан securityProtocol
kafka.empty.ssl.truststore.location=Не задан sslTruststoreLocation
kafka.empty.ssl.truststore.password=Не задан sslTruststorePassword
kafka.empty.ssl.keystore.password=Не задан sslKeystorePassword
kafka.empty.ssl.key.password=Не задан sslKeyPassword
kafka.empty.sasl.kerberos.service.name=Не задан saslKerberosServiceName
kafka.empty.sasl.oauth.bearer.token.endpoint=Не задан saslOauthBearerTokenEndpoint
kafka.empty.sasl.oauth.bearer.jwks.endpoint=Не задан saslOauthBearerJwksEndpoint
kafka.empty.client.id=Не задан clientId
kafka.empty.client.secret=Не задан clientSecret
kafka.empty.username=Не задан username
kafka.empty.password=Не задан password
kafka.step.consumer.read.first=Вычитываем сообщение из топика: "{topic}" по словам поиска: {logValue}
kafka.step.consumer.read.all=Вычитываем сообщения из топика: "{topic}" по словам поиска: {logValue}
kafka.step.consumer.subscribe=Подписываемся на топик: "{topic.topic}"
kafka.step.consumer.unsubscribe.after.key=Осуществляем отписку от топика: "{topic}" после получения сообщения содержащего: {logValue}
kafka.step.producer.send=Отправляем сообщение в топик: {topic}

# Hibernate
hibernate.null.attachment=Пустое Allure вложение
hibernate.empty.result=Пустой результат запроса
hibernate.query.word=SQL запрос
hibernate.result.word=Результат
hibernate.updated.words=Изменено
hibernate.updated.word=Изменена
hibernate.deleted.words=Удалено
hibernate.deleted.word=Удалена
hibernate.inserted.words=Вставлено
hibernate.inserted.word=Вставлена
hibernate.one.row=строка
hibernate.two.rows=строки
hibernate.many.rows=строк
hibernate.excel.result.value.error=Ошибка во время записи значения в Excel. %s
hibernate.excel.big.value=Смотри данные в БД. Длина превышает 32767 символов(32 КБ)
hibernate.change.param.not.found=Параметр для изменения не найден: %s
hibernate.max.result.zero.value.error=Значение [maxResult] должно быть больше 0
hibernate.empty.result.query=Не найдено ни одной записи для запроса
hibernate.not.valid.param.set.error=Задан недопустимый параметр в запросе\n%s
hibernate.execute.query.error=Ошибка при выполнении запроса\n
hibernate.set.param.error=Ошибка при подстановке параметра [%s] в запрос\n
hibernate.max.result.value.error=Ошибка при установке значения [maxResult]\n
hibernate.first.result.value.error=Ошибка при установке значения [firstResult]\n
hibernate.change.param.error=Ошибка при подстановке параметра [%s] в запрос\n
hibernate.query.error=Допущена ошибка при написании запроса\n
hibernate.attempt=Попытка: {}
hibernate.props.null=Hibernate параметры для подключения отсутствуют
hibernate.connect.to.db.error=Не удалось подключиться к БД\n%s

# IBM MQ
ibm.mq.success.sent=Сообщение успешно отправлено в очередь: {}\n{}\n
ibm.mq.success.read=Сообщение успешно вычитано из очереди: {}\n{}\n
ibm.mq.success.read.many=Сообщения успешно вычитаны из очереди: {}\n{}\n
ibm.mq.end.read=Окончена вычитка из очереди: {}. Сообщения не найдены.\n
ibm.mq.convert.bytes.error=Ошибка при попытке конвертации сообщения в строку
ibm.mq.props.null=IBM MQ параметры для подключения отсутствуют
ibm.mq.connect.error=Не удалось подключиться к IBM MQ\n
ibm.mq.close.conn.error=Ошибка при закрытии соединения с IBM MQ.\n%s\n
ibm.mq.attempt=Попытка: {}
ibm.mq.create.browser.error=Ошибка при попытке создания IBM MQ Browser
ibm.mq.create.consumer.error=Ошибка при попытке создания IBM MQ Consumer
ibm.mq.create.producer.error=Ошибка при попытке создания IBM MQ Producer
ibm.mq.browser.start.read=IBM MQ Browser. Старт вычитки сообщений из очереди [{}]
ibm.mq.no.messages=Не найдено сообщений
ibm.mq.read.fail=Ошибка при вычитке сообщений
ibm.mq.consumer.start.read=IBM MQ Consumer. Старт вычитки сообщений из очереди [{}]
ibm.mq.producer.start.sending=IBM MQ Producer. Старт отправки сообщения в очередь [{}]
ibm.mq.producer.error.sending=Ошибка при отправке сообщения в очередь
ibm.mq.step.consumer.read=Вычитываем сообщение из очереди: {queue.queue}
ibm.mq.step.browser.read=Вычитываем сообщение из очереди: {queue.queue}
ibm.mq.step.producer.send=Отправляем сообщение в очередь: {queue.queue}

# Rest
rest.name.null.error=Имя не должно быть null
rest.url.null.error=Url не должен быть null
rest.header.name.null.error=Имя заголовка не должно быть null
rest.header.value.null.error=Значение заголовка не должно быть null
rest.headers.null.error=Заголовки не должны быть null
rest.cookie.name.null.error=Имя cookie не должно быть null
rest.cookie.value.null.error=Значение cookie не должно быть null
rest.cookies.null.error=Cookies не должны быть null
rest.body.null.error=Тело не должно быть null
rest.method.null.error=Метод не должен быть null
rest.response.created.error=Ответ должен быть создан
rest.step.response.body.should.be.empty=Тело ответа должно быть пустое
rest.step.response.contain.empty.list=Ответ должен содержать пустой список
rest.step.response.by.path.contain.empty.list=Ответ по пути {0} должен содержать пустой список
rest.step.response.body.with.no.content=Тело ответа должно содержать пустой контент
rest.step.response.body.by.path.should.be.empty=Тело ответа по пути {0} должно быть пустое
rest.step.response.body.by.path.should.be.not.empty=Тело ответа по пути {0} должно быть не пустое
rest.step.response.time.seconds.should.be.greater.than=Время ответа должно быть больше чем {0} секунд
rest.step.response.time.seconds.should.be.less.than=Время ответа должно быть меньше чем {0} секунд
rest.step.response.time.ms.should.be.greater.than=Время ответа должно быть больше чем {0} мс
rest.step.response.time.ms.should.be.less.than=Время ответа должно быть меньше чем {0} мс
rest.step.response.status.code=Статус код ответа должен быть

# Selenide
selenide.cookie.not.found.error=Cookie [%s] не найдено
selenide.step.open.url=Перейти по URL "{url}"
selenide.step.current.url=Получить текущий URL
selenide.step.refresh.page=Обновить страницу
selenide.step.close.driver=Закрыть браузер
selenide.step.close.window=Закрыть текущую вкладку браузера
selenide.step.browser.size=Установить размер окна браузера "{width} x {height}"
selenide.step.back=Вернуться на страницу назад
selenide.step.forward=Вернуться на страницу вперёд
selenide.step.switch.to.window=Перейти на вкладку браузера под номером {windowNumber}
selenide.step.get.local.storage=Получить localStorage браузера по ключу "{key}"
selenide.step.set.item.in.local.storage=Добавить localStorage с ключом "{key}"
selenide.step.get.cookies=Получить cookies браузера
selenide.step.get.cookie.by.name=Получить cookie браузера: {cookieName}
selenide.step.set.cookie=Установить cookie браузера: {cookieName}
selenide.step.clear.browser.local.storage=Очистить кэш браузера
selenide.step.clear.browser.cookies=Очистить cookies браузера
selenide.step.clear.browser.cookies.and.local.storage=Очистить кэш и cookies браузера
selenide.step.execute.java.script=Выполнить синхронный JavaScript в браузере
selenide.step.execute.async.java.script=Выполнить асинхронный JavaScript в браузере

# WebSocket
websocket.props.null=WebSocket параметры для подключения отсутствуют
websocket.connect.error=Ошибка при подключении к WebSocket.\n%s
websocket.unsubscribe.no.topic.error=На топик [%s] не осуществлялась подписка
websocket.read.error=Возникла ошибка при чтении из топика [%s]\n%s
websocket.subscribe.already.exist=На топик [%s] уже осуществлена подписка
websocket.new.connect=Установлено новое соединение по WebSocket: {}
websocket.exception=WebSocket ошибка. {}
websocket.received=Полученные сообщения по WebSocket:\n{}
websocket.disconnect=Завершена подписка WebSocket на топик: {}
websocket.connect.to.topic=Осуществлена подписка WebSocket на топик: {}
websocket.no.records.while.subscribe=Не получено сообщений за время подписки на WebSocket топик: "%s"
websocket.step.subscribe=Осуществляем подписку на WebSocket топик: "{wsTopic.topic}"
websocket.step.unsubscribe.and.get.results=Осуществляем отписку от WebSocket топика: "{wsTopic.topic}" и получаем результат

# Asserts
asserts.step.assert.true=Проверка "{field}": true
asserts.step.assert.false=Проверка "{field}": false
asserts.step.assert.null=Проверка "{field}": null
asserts.step.assert.not.null=Проверка "{field}": not null
asserts.step.assert.equals=Проверка "{field}": "{expected}"
asserts.step.assert.equals.with.delta=Проверка "{field}": "{expected}", delta: {delta}
asserts.step.assert.equals.with.ignoring.case=Проверка "{field}": "{expected}" с игнорированием регистра
asserts.step.assert.lines.match=Проверка "{field}": "{expectedLines}"
asserts.step.assert.not.equals=Проверка, что "{field}" не соответствует "{unexpected}"
asserts.step.assert.not.equals.with.delta=Проверка, что "{field}" не соответствует "{unexpected}", delta: {delta}
asserts.step.assert.throws.exactly=Проверка, что "{executable}" не содержит исключений
asserts.step.assert.does.not.throw=Проверка, что "{supplier}" не содержит исключений
asserts.step.assert.timeout=Проверка, что "{executable}" выполняется не более {timeout}
asserts.step.assert.timeout.supplier=Проверка, что "{supplier}" выполняется не более {timeout}
asserts.step.assert.instance.of=Проверка, что "{actualValue}" является экземпляром {expectedType}
asserts.step.assert.list.equals=Проверка "{field}": "{expectedList}"
asserts.step.assert.list.contains=Проверка, что "{field}" содержит "{expectedValue}"
asserts.step.assert.list.size=Проверка размера списка "{field}": {size}
asserts.step.assert.time.is.after=Проверка, что "{field}" после "{expected}"
asserts.step.assert.time.is.after.or.equal.to=Проверка, что "{field}" после или равно "{expected}"
asserts.step.assert.time.is.before=Проверка, что "{field}" до "{expected}"
asserts.step.assert.time.is.before.or.equal.to=Проверка, что "{field}" до или равно "{expected}"
asserts.step.assert.time.is.between=Проверка, что "{field}" между "{expectedStartTime}" и "{expectedEndTime}"
asserts.step.assert.date.is.between=Проверка, что "{field}" между "{expectedStartDate}" и "{expectedEndDate}"
asserts.step.assert.time.is.between.or.equal.to=Проверка, что "{field}" между или равно "{expectedStartTime}" и "{expectedEndTime}"
asserts.step.assert.date.is.between.or.equal.to=Проверка, что "{field}" между или равно "{expectedStartDate}" и "{expectedEndDate}"
asserts.step.assert.start.with=Проверка, что "{field}" начинается с "{expectedPrefix}"
asserts.step.assert.start.with.ignoring.case=Проверка, что "{field}" начинается с "{expectedPrefix}" с игнорированием регистра
asserts.step.assert.not.start.with=Проверка, что "{field}" не начинается с "{expectedNotPrefix}"
asserts.step.assert.not.start.with.ignoring.case=Проверка, что "{field}" не начинается с "{expectedNotPrefix}" с игнорированием регистра
asserts.step.assert.end.with=Проверка, что "{field}" заканчивается на "{expectedSuffix}"
asserts.step.assert.end.with.ignoring.case=Проверка, что "{field}" заканчивается на "{expectedSuffix}" с игнорированием регистра
asserts.step.assert.not.end.with=Проверка, что "{field}" не заканчивается на "{expectedNotSuffix}"
asserts.step.assert.not.end.with.ignoring.case=Проверка, что "{field}" не заканчивается на "{expectedNotSuffix}" с игнорированием регистра
asserts.step.assert.not.equals.with.ignoring.case=Проверка, что "{field}" не соответствует "{notExpected}" с игнорированием регистра
asserts.step.assert.equals.with.ignoring.whitespace=Проверка "{field}": "{expected}" с игнорированием пробелов
asserts.step.assert.not.equals.with.ignoring.whitespace=Проверка, что "{field}" не соответствует "{notExpected}" с игнорированием пробелов
asserts.step.assert.contains.only.whitespaces=Проверка, что "{field}" содержит только пробелы
asserts.step.assert.contains.whitespaces=Проверка, что "{field}" содержит пробелы
asserts.step.assert.not.contains.whitespaces=Проверка, что "{field}" не содержит пробелы
asserts.step.validate.xml.against.xsd.schema=Валидация XML-сообщения относительно XSD-схемы

# Cartesian Source
cartesian.axis.no.value=У оси "%s" отсутствуют значения
cartesian.value.no.value=CartesianValue '%s' не дало никаких значений: должен быть определен хотя бы один источник
cartesian.bad.exclude.value=Неверное исключаемое значение: '%s'. Ожидаемое значение 'key=value'
cartesian.unknown.exclude.cartesian.value=Исключение относится к неизвестному CartesianValue: %s
cartesian.not.static.field=Поле '%s' должно быть static
cartesian.cannot.read.field=Ошибка при обработке поля '%s' в '%s'
cartesian.cannot.invoke.method=Не удается вызвать метод '%s' в '%s'
cartesian.found.unsuitable.methods=Найденные методы называются '%s', но ни один из них не является статическим и не содержит параметров в '%s'
cartesian.no.found.methods=Не найден метод с именем '%s' в '%s'
cartesian.unsupported.array=Не поддерживается возвращаемый тип: '%s'. Используйте Stream/Iterable/Array
cartesian.type.must.have.no.args.ctor=Не удается создать экземпляр %s (должен быть no-arg конструктор)
cartesian.axis.diff.sizes=Ось "%s" создала кортежи разных размеров: %d vs %d. Приведите их в соответствие
cartesian.axis.column.length=Ось '%s': длина столбцов() (%d) должна соответствовать арности кортежа (%d)